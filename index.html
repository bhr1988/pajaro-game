<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pájaro - Phase 1</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a237e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #gameCanvas {
            border: 2px solid #3f51b5;
            background-color: #283593;
            display: block;
            max-width: 95vw;
            height: auto;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- AUDIO SETUP ---
        // Added the missing audioContext that was causing the crash
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        const bgMusic = new Audio('pajaro_slowed_v2.mp3');
        const fastMusic = new Audio('pajaro_fast.mp3'); 

        bgMusic.loop = true;
        fastMusic.loop = true;
        bgMusic.volume = 0.4;
        fastMusic.volume = 0.4;

        function playBeep() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = 600;
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playBuzz() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = 150;
            oscillator.type = 'sawtooth';
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }

        // --- GAME STATE ---
        const HIGH_SCORE_KEY = 'pajaro_high_score';
        function getHighScore() {
            const saved = localStorage.getItem(HIGH_SCORE_KEY);
            return saved ? parseInt(saved, 10) : 0;
        }
        function saveHighScore(newScore) {
            localStorage.setItem(HIGH_SCORE_KEY, newScore.toString());
        }

        let gameOver = false;
        let gameStarted = false;
        let score = 0;
        let hearts = 5;
        let invincible = false;
        let invincibleTimer = 0;
        let wingFlap = 0;
        let highScore = getHighScore();
        let newHighScore = false;
        let flashTimer = 0;

        const bird = {
            x: 100,
            y: 200,
            radius: 35,
            velocity: 0,
            color: '#39FF14',
            rotation: 0
        };

        let trailParticles = [];
        const TRAIL_LENGTH = 5;
        const GRAVITY = 0.15;
        const JUMP_STRENGTH = -5;
        const BASE_PILLAR_SPEED = 2;
        const PILLAR_WIDTH = 80;
        const PILLAR_GAP = 200;
        let pillarSpeed = BASE_PILLAR_SPEED;
        const PILLAR_SPACING = 700;
        const CLOUD_COUNT = 5;
        const CLOUD_SPEED = 0.3;

        let pillars = [];
        let clouds = [];
        let backgroundTrees = [];
        const BACKGROUND_TREE_COUNT = 8;

        // --- INITIALIZATION FUNCTIONS ---
        function createBackgroundTrees() {
            backgroundTrees = [];
            for (let i = 0; i < BACKGROUND_TREE_COUNT; i++) {
                backgroundTrees.push({
                    x: Math.random() * canvas.width * 2,
                    y: canvas.height,
                    trunkWidth: 20 + Math.random() * 15,
                    trunkHeight: 100 + Math.random() * 150,
                    treeWidth: 60 + Math.random() * 80
                });
            }
        }

        function createClouds() {
            clouds = [];
            for (let i = 0; i < CLOUD_COUNT; i++) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.7,
                    width: 80 + Math.random() * 60,
                    height: 40 + Math.random() * 30
                });
            }
        }

        function createPillar() {
            const minGapY = PILLAR_GAP / 2 + 50;
            const maxGapY = canvas.height - PILLAR_GAP / 2 - 50;
            const gapY = Math.random() * (maxGapY - minGapY) + minGapY;
            pillars.push({
                x: canvas.width,
                gapY: gapY,
                scored: false
            });
        }

        // --- DRAWING FUNCTIONS ---
        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#4a148c');
            gradient.addColorStop(0.5, '#6a1b9a');
            gradient.addColorStop(1, '#ff6f00');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawBackgroundTrees() {
            backgroundTrees.forEach(tree => {
                ctx.fillStyle = 'rgba(101, 67, 33, 0.6)';
                ctx.fillRect(tree.x - tree.trunkWidth / 2, tree.y - tree.trunkHeight, tree.trunkWidth, tree.trunkHeight);
                ctx.fillStyle = 'rgba(34, 139, 34, 0.5)';
                ctx.beginPath();
                ctx.moveTo(tree.x, tree.y - tree.trunkHeight);
                ctx.lineTo(tree.x - tree.treeWidth / 2, tree.y - tree.trunkHeight + tree.treeWidth / 2);
                ctx.lineTo(tree.x + tree.treeWidth / 2, tree.y - tree.trunkHeight + tree.treeWidth / 2);
                ctx.fill();
            });
        }

        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            clouds.forEach(cloud => {
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y, cloud.width / 2, cloud.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPillars() {
            pillars.forEach(pillar => {
                const gapBottom = pillar.gapY + PILLAR_GAP / 2;
                const trunkX = pillar.x + PILLAR_WIDTH / 2;
                const trunkWidth = PILLAR_WIDTH * 0.6;
                
                ctx.fillStyle = '#654321';
                ctx.fillRect(trunkX - trunkWidth / 2, gapBottom, trunkWidth, canvas.height - gapBottom);

                const treeTopY = gapBottom;
                const treeTopHeight = Math.min((canvas.height - gapBottom) * 0.4, 60);
                ctx.fillStyle = '#2d5016';
                ctx.beginPath();
                ctx.moveTo(trunkX, treeTopY - treeTopHeight);
                ctx.lineTo(pillar.x, treeTopY);
                ctx.lineTo(pillar.x + PILLAR_WIDTH, treeTopY);
                ctx.fill();

                ctx.fillStyle = '#3d6b1f';
                const topHeight = pillar.gapY - PILLAR_GAP / 2;
                const branchTrunkHeight = Math.min(topHeight * 0.7, 40);
                ctx.fillRect(trunkX - trunkWidth / 2, 0, trunkWidth, branchTrunkHeight);
            });
        }

        function drawBird() {
            bird.rotation = Math.max(-0.5, Math.min(0.5, bird.velocity / 10));
            if (!invincible || Math.floor(invincibleTimer / 5) % 2 === 0) {
                ctx.save();
                ctx.translate(bird.x, bird.y);
                ctx.rotate(bird.rotation);
                ctx.fillStyle = '#DC143C';
                ctx.beginPath();
                ctx.ellipse(0, 0, 30, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                const wingAngle = Math.sin(Date.now() * 0.01) * 0.4;
                ctx.fillStyle = '#FFD700';
                ctx.save();
                ctx.translate(0, -8);
                ctx.rotate(wingAngle);
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(18, -6, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(20, -6, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#808080';
                ctx.beginPath();
                ctx.moveTo(30, 0); ctx.lineTo(25, -4); ctx.lineTo(25, 4);
                ctx.fill();
                ctx.restore();
            }
        }

        function drawTrail() {
            trailParticles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(57, 255, 20, ${p.opacity})`;
                ctx.fill();
            });
        }

        function drawHearts() {
            ctx.fillStyle = '#ff1744';
            ctx.font = '32px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < hearts; i++) {
                ctx.fillText('♥', 20 + (i * 35), 40);
            }
        }

        function drawScore() {
            ctx.fillStyle = 'white';
            ctx.font = '36px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('Score: ' + score, canvas.width - 20, 40);
        }

        function drawStartScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Tap to Start', canvas.width / 2, canvas.height / 2);
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 100);
            ctx.font = '32px Arial';
            ctx.fillText('Score: ' + score, canvas.width / 2, canvas.height / 2 - 30);
            ctx.fillText('High Score: ' + highScore, canvas.width / 2, canvas.height / 2 + 20);
            ctx.font = '24px Arial';
            ctx.fillText('Tap to restart', canvas.width / 2, canvas.height / 2 + 70);
        }

        // --- LOGIC FUNCTIONS ---
        function calculatePillarSpeed() {
            const speedMultiplier = 1 + (Math.floor(score / 5) * 0.1);
            return BASE_PILLAR_SPEED * speedMultiplier;
        }

        function updatePillars() {
            if (!gameStarted) return;
            pillarSpeed = calculatePillarSpeed();
            for (let i = pillars.length - 1; i >= 0; i--) {
                pillars[i].x -= pillarSpeed;
                if (!pillars[i].scored && pillars[i].x + PILLAR_WIDTH < bird.x) {
                    score++;
                    // Strike 2: Music Switch
                    if (score === 10) {
                        bgMusic.pause();
                        bgMusic.currentTime = 0;
                        fastMusic.play().catch(e => console.log("Fast music triggered"));
                    }
                    pillars[i].scored = true;
                }
                if (pillars[i].x + PILLAR_WIDTH < 0) pillars.splice(i, 1);
            }
            if (pillars.length === 0 || pillars[pillars.length - 1].x < canvas.width - PILLAR_SPACING) {
                createPillar();
            }
        }

        function checkPillarCollision() {
            if (invincible || !gameStarted) return;
            pillars.forEach(p => {
                if (bird.x + bird.radius > p.x && bird.x - bird.radius < p.x + PILLAR_WIDTH) {
                    const gapTop = p.gapY - PILLAR_GAP / 2;
                    const gapBottom = p.gapY + PILLAR_GAP / 2;
                    if (bird.y - bird.radius < gapTop || bird.y + bird.radius > gapBottom) {
                        hearts--;
                        invincible = true;
                        invincibleTimer = 120;
                        playBuzz();
                        if (hearts <= 0) endGame();
                    }
                }
            });
        }

        function checkBottomCollision() {
            if (!gameStarted) return;
            if (bird.y + bird.radius >= canvas.height) {
                if (!invincible) {
                    hearts--;
                    invincible = true;
                    invincibleTimer = 120;
                    playBuzz();
                    if (hearts <= 0) endGame();
                }
                bird.y = canvas.height - bird.radius;
                bird.velocity = 0;
            }
        }

        function endGame() {
            gameOver = true;
            gameStarted = false;
            // Stop all music on Game Over
            bgMusic.pause();
            fastMusic.pause();
            if (score > highScore) {
                highScore = score;
                saveHighScore(highScore);
                newHighScore = true;
            }
        }

        function updateBird() {
            if (!gameStarted) return;
            bird.velocity += GRAVITY;
            if (bird.velocity > 10) bird.velocity = 10;
            bird.y += bird.velocity;
        }

        function updateTrail() {
            if (Math.floor(Date.now() / 50) % 2 === 0) {
                trailParticles.push({ x: bird.x, y: bird.y, opacity: 0.8, size: 8 });
            }
            if (trailParticles.length > TRAIL_LENGTH) trailParticles.shift();
            trailParticles.forEach((p, i) => {
                p.opacity -= 0.15;
                p.size -= 0.3;
                if (p.opacity <= 0) trailParticles.splice(i, 1);
            });
        }

        function resetGame() {
            bird.y = 200; bird.velocity = 0;
            gameOver = false; gameStarted = false;
            score = 0; hearts = 5;
            invincible = false; invincibleTimer = 0;
            pillars = []; trailParticles = [];
            // Strike 3: Reset Music
            fastMusic.pause();
            fastMusic.currentTime = 0;
            bgMusic.currentTime = 0;
            bgMusic.play().catch(e => console.log("Audio reset"));
            createPillar();
        }

        // --- INPUTS ---
        window.addEventListener('touchstart', e => {
            if (!gameStarted && !gameOver) {
                gameStarted = true;
                bgMusic.play();
            } else if (gameStarted && !gameOver) {
                bird.velocity = JUMP_STRENGTH;
                playBeep();
            } else if (gameOver) {
                resetGame();
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('click', () => { if (gameOver) resetGame(); });

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSky();
            if (!gameOver) {
                updateBird();
                updatePillars();
                updateTrail();
                checkPillarCollision();
                checkBottomCollision();
                if (invincible) {
                    invincibleTimer--;
                    if (invincibleTimer <= 0) invincible = false;
                }
            }
            drawBackgroundTrees();
            drawClouds();
            drawTrail();
            drawPillars();
            drawBird();
            drawHearts();
            drawScore();
            if (!gameStarted && !gameOver) drawStartScreen();
            if (gameOver) drawGameOver();
            requestAnimationFrame(gameLoop);
        }

        createBackgroundTrees();
        createClouds();
        createPillar();
        gameLoop();
    </script>
</body>
</html>
